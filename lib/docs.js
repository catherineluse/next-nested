import fs from 'fs-extra';
import path from 'path';

import matter from 'gray-matter';
import remark, { data } from 'remark';
import html from 'remark-html';

// Wrapper to flatten and return nested path list as flat array expected by next
export async function getPathList(folder, ogPath, pageFileCache) {
  let nestedPaths = await getNestedPathList(folder, ogPath, pageFileCache);
  return flatten(nestedPaths).filter((x) => !!x);
}

// Recursivly scan the documentation folder. This includes any extra resolution magic
// such as index.md acting as the folder index
export async function getNestedPathList(folder, ogPath, pageFileCache) {
  return (
    await Promise.all(
      (await fs.readdir(folder)).map(async (file) => {
        const joined = path.join(folder, file);

        //  Call recursively if a directory
        if ((await fs.stat(joined)).isDirectory()) {
          return getNestedPathList(joined, ogPath, pageFileCache);
        }

        // If a content markdown is found
        if (joined.endsWith('.md')) {
          let alteredPath = joined
            .slice(folder.length + 1)
            .replace(/\.md$/, '')
            .replace(/\index$/, '');

          // In recursive depths, add folder name and trim any stray '/'
          if (folder !== ogPath) {
            alteredPath = folder.replace(ogPath, '') + '/' + alteredPath;
          }
          alteredPath = trimChar(alteredPath, '/');

          pageFileCache[alteredPath] = joined;
          return {
            params: {
              id: alteredPath.split('/'),
            },
          };
        } else {
          return null;
        }
      })
    )
  ).filter((x) => !!x);
}

export async function getPostData(id, fullPath) {
  const fileContents = fs.readFileSync(fullPath, 'utf8');

  // Use gray-matter to parse the post metadata section
  const matterResult = matter(fileContents);

  // Use remark to convert markdown into HTML string
  const processedContent = await remark()
    .use(html)
    .process(matterResult.content);
  const contentHtml = processedContent.toString();

  // Combine the data with the id and contentHtml
  return {
    id,
    contentHtml,
    text: matterResult.content,
    ...matterResult.data,
  };
}

export async function getSortedFlatData(folder) {
  let fullFolderPath = path.join(process.cwd(), '/' + folder);
  // Get file names under /posts
  const pageFileCache = {};
  const paths = await getPathList(
    fullFolderPath,
    fullFolderPath,
    pageFileCache
  );

  const allPostsData = paths
    .map((p) => p.params.id.join('/'))
    .map((fileName) => {
      const id = fileName;

      // Read markdown file as string
      const fullPath = pageFileCache[id];
      const fileContents = fs.readFileSync(fullPath, 'utf8');

      // Use gray-matter to parse the post metadata section
      const matterResult = matter(fileContents);

      // Combine the data with the id
      return {
        id,
        ...matterResult.data,
      };
    });
  // Sort posts by date
  return allPostsData.sort((a, b) => {
    if (a.id > b.id) {
      return 1;
    } else {
      return -1;
    }
  });
}

// helper function useful to quickly print the nested paths while debugging
function printPaths(paths, space = '') {
  for (let path of paths) {
    if (!Array.isArray(path)) {
      console.log(space, path.params.id);
    } else {
      printPaths(path, space + ' ');
    }
  }
}

// Generate nested data from nested paths and pageFileCache
// Input paths, pageFileCache generated by getNestedPathList()
function nestData(paths, pageFileCache, start = ['']) {
  // output = {
  //   type: 'folder',
  //   id: '',
  //   path: 'fullpath',
  //   matter: {frontmatter YAML}
  //   files: [
  //     {
  //       type: 'file',
  //       path: 'fullpath'
  //       id: 'slug/id'
  //       matter: ...
  //     },
  //     {
  //       type: 'file',
  //       ...
  //     },
  //     {
  //       type: 'folder',
  //       ...
  //       files: [
  //         ...
  //       ],
  //     },
  //   ]
  // }
  let files = [];
  let startPath = pageFileCache[start.join('/')];

  // Remove the element start by compairing ID array
  paths = paths.filter((p) => {
    return (
      Array.isArray(p) ||
      !(
        p.params.id.length === start.length &&
        p.params.id.every((value, index) => value === start[index])
      )
    );
  });

  for (let path of paths) {
    if (!Array.isArray(path)) {
      let id = path.params.id.join('/');
      let fullPath = pageFileCache[id];

      // Use gray-matter to parse the post metadata section
      const fileContents = fs.readFileSync(fullPath, 'utf8');
      const matterResult = matter(fileContents);

      files.push({
        type: 'file',
        id: id,
        path: pageFileCache[id],
        matter: matterResult.data,
      });
    } else {
      // New start will have smallest id length
      let newStart = path.reduce((str, p) => {
        if (!Array.isArray(p)) {
          if (Array.isArray(str)) {
            return p;
          }
          return str.params.id.length < p.params.id.length ? str : p;
        }
        return str;
      }).params.id;

      files.push(nestData(path, pageFileCache, newStart));
    }
  }

  // Use gray-matter to parse the post metadata section
  const fileContents = fs.readFileSync(startPath, 'utf8');
  const matterResult = matter(fileContents);

  return {
    type: 'folder',
    id: start.join('/'),
    path: startPath,
    matter: matterResult.data,
    files: files,
  };
}

export async function getFolderNestedData(folder) {
  let fullFolderPath = path.join(process.cwd(), '/' + folder);

  const pageFileCache = {};
  const paths = await getNestedPathList(
    fullFolderPath,
    fullFolderPath,
    pageFileCache
  );

  return nestData(paths, { ...pageFileCache });
}

// Escape special characters for use in a regular expression
var escapeRegExp = function (strToEscape) {
  return strToEscape.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
};

// Trim Characters at the start and the end
var trimChar = function (origString, charToTrim) {
  charToTrim = escapeRegExp(charToTrim);
  var regEx = new RegExp('^[' + charToTrim + ']+|[' + charToTrim + ']+$', 'g');
  return origString.replace(regEx, '');
};

// Flattens nested arrays
function flatten(items) {
  const flat = [];

  items.forEach((item) => {
    if (Array.isArray(item)) {
      flat.push(...flatten(item));
    } else {
      flat.push(item);
    }
  });

  return flat;
}
