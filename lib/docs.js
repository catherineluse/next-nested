import fs from 'fs-extra';
import path from 'path';

import matter from 'gray-matter';
import remark, { data } from 'remark';
import html from 'remark-html';

// Recursivly scan the documentation folder. This includes any extra resolution magic
// such as index.mdx acting as the folder index
export async function getPathList(folder, ogPath, pageFileCache) {
  return (
    await Promise.all(
      (await fs.readdir(folder)).map(async (file) => {
        const joined = path.join(folder, file);

        //  Call recursively if a directory
        if ((await fs.stat(joined)).isDirectory()) {
          return getPathList(joined, ogPath, pageFileCache);
        }

        // If a content markdown is found
        if (joined.endsWith('.md')) {
          let alteredPath = joined
            .slice(folder.length + 1)
            .replace(/\.md$/, '')
            .replace(/\index$/, '');

          // In recursive depths, add folder name and trim any stray '/'
          if (folder !== ogPath) {
            alteredPath = folder.replace(ogPath, '') + '/' + alteredPath;
          }
          alteredPath = trimChar(alteredPath, '/');

          pageFileCache[alteredPath] = joined;
          return {
            params: {
              id: alteredPath.split('/'),
            },
          };
        } else {
          return null;
        }
      })
    )
  )
    .flat()
    .filter((x) => !!x);
}

export async function getPostData(id, fullPath) {
  const fileContents = fs.readFileSync(fullPath, 'utf8');

  // Use gray-matter to parse the post metadata section
  const matterResult = matter(fileContents);

  // Use remark to convert markdown into HTML string
  const processedContent = await remark()
    .use(html)
    .process(matterResult.content);
  const contentHtml = processedContent.toString();

  // Combine the data with the id and contentHtml
  return {
    id,
    contentHtml,
    ...matterResult.data,
  };
}

export async function getSortedFlatData(folder) {
  let fullFolderPath = path.join(process.cwd(), '/' + folder);
  // Get file names under /posts
  const pageFileCache = {};
  const paths = await getPathList(
    fullFolderPath,
    fullFolderPath,
    pageFileCache
  );

  const allPostsData = paths
    .map((p) => p.params.id.join('/'))
    .map((fileName) => {
      const id = fileName;

      // Read markdown file as string
      const fullPath = pageFileCache[id];
      const fileContents = fs.readFileSync(fullPath, 'utf8');

      // Use gray-matter to parse the post metadata section
      const matterResult = matter(fileContents);

      // Combine the data with the id
      return {
        id,
        ...matterResult.data,
      };
    });
  // Sort posts by date
  return allPostsData.sort((a, b) => {
    if (a.id > b.id) {
      return 1;
    } else {
      return -1;
    }
  });
}

// Data Structure for nested display:
const sampleData = [
  {
    type: 'folder',
    id: '',
    title: 'INDEX OF THE WALL OF SHAMEMEMEMEM',
    date: '2020-01-02',
    files: [
      {
        type: 'file',
        id: 'contributing',
        title: 'Contributionsnsn',
        date: '2020-01-03',
      },
      {
        id: 'faq',
        type: 'file',
        title: 'Funkquently asked qwestions',
        date: '2020-01-02',
      },
      {
        type: 'folder',
        id: 'getting-started',
        title: 'Getting Started Index',
        date: '2020-01-03',
        files: [
          {
            type: 'file',
            id: 'getting-started/installation',
            title: 'Installation',
            date: '2020-01-01',
          },
          {
            type: 'file',
            id: 'getting-started/quickstart',
            title: 'Quick Start',
            date: '2020-01-02',
          },
        ],
      },
      {
        type: 'folder',
        id: 'reference',
        title: 'FUnktions',
        date: '2020-01-03',
        files: [
          {
            type: 'file',
            id: 'reference/components',
            title: 'KOMOPONENTS',
            date: '2020-01-04',
          },
          {
            type: 'file',
            id: 'reference/functions',
            title: 'FUnktions',
            date: '2020-01-03',
          },
        ],
      },
    ],
  },
];

function nestData(pageFileCache, start = '', slug = '') {
  // Input pageFileCache generated by getPathList
  // let output = {
  //   type: 'folder',
  //   id: '',
  //   path: 'fullpath',
  //   matter: {frontmatter YAML}
  //   files: [
  //     {
  //       type: 'file',
  //       path: 'fullpath'
  //       id: 'slug/id'
  //       matter: ...
  //     },
  //     {
  //       type: 'file',
  //       ...
  //     },
  //     {
  //       type: 'folder',
  //       ...
  //       files: [
  //         ...
  //       ],
  //     },
  //   ]
  // }
  let files = [];
  let startPath = pageFileCache[start];
  delete pageFileCache[start];

  let emStart;
  if (slug !== '') {
    emStart = slug + '/';
  } else {
    emStart = slug;
  }

  // Sorted key order for alphabetical list
  for (let page of Object.keys(pageFileCache).sort()) {
    let fullPath = pageFileCache[page];

    if (!fullPath.includes('index.md') && !page.includes('/')) {
      const fileContents = fs.readFileSync(fullPath, 'utf8');

      // Use gray-matter to parse the post metadata section
      const matterResult = matter(fileContents);

      files.push({
        type: 'file',
        id: emStart + page,
        path: pageFileCache[page],
        matter: matterResult.data,
      });
    }
    if (
      fullPath.includes(slug + '/' + page + '/index.md') &&
      !page.includes('/')
    ) {
      // generate new cache
      let newCache = { [page]: fullPath };

      for (let key in { ...pageFileCache }) {
        if (key.startsWith(page)) {
          newCache[key.substring(key.indexOf('/') + 1)] = pageFileCache[key];
        }
      }

      let newSlug = trimChar(slug + '/' + page, '/');
      files.push(nestData(newCache, page, newSlug));
    }
  }

  const fileContents = fs.readFileSync(startPath, 'utf8');
  // Use gray-matter to parse the post metadata section
  const matterResult = matter(fileContents);

  return {
    type: 'folder',
    id: trimChar(start, '/'),
    path: startPath,
    matter: matterResult.data,
    files: files,
  };
}

export async function getFolderNestedData(folder) {
  let fullFolderPath = path.join(process.cwd(), '/' + folder);
  // Get file names under /posts
  const pageFileCache = {};
  await getPathList(fullFolderPath, fullFolderPath, pageFileCache);

  return nestData({ ...pageFileCache });
}

var escapeRegExp = function (strToEscape) {
  // Escape special characters for use in a regular expression
  return strToEscape.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
};

var trimChar = function (origString, charToTrim) {
  charToTrim = escapeRegExp(charToTrim);
  var regEx = new RegExp('^[' + charToTrim + ']+|[' + charToTrim + ']+$', 'g');
  return origString.replace(regEx, '');
};
